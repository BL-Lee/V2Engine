float triangleTest(vec3 rayOrigin, vec3 rayDirection, vec3 v0, vec3 v1, vec3 v2, vec3 normal)
{
	      
  float denom = dot(normal, rayDirection);

  float triangleOffset = -dot(normal, v2); //like the planeDist but for the triangle
  float triangleDist = -(dot(normal, rayOrigin) + triangleOffset) / denom; 
		
  bool triangleHitMask = true;

  if (triangleDist < 0.0001)
    return FLT_MAX;
  vec3 planePoint = (rayDirection * triangleDist) + rayOrigin;
  
  vec3 edge0 = v1 - v0;
  vec3 edgePerp = cross(edge0, planePoint - v0);
  triangleHitMask = triangleHitMask && (dot(normal, edgePerp) > 0.0);

  vec3 edge1 = v2 - v1;
  edgePerp = cross(edge1, planePoint - v1);
  triangleHitMask = triangleHitMask && (dot(normal, edgePerp) > 0.0);

  vec3 edge2 = v0 - v2;
  edgePerp = cross(edge2, planePoint - v2);
  triangleHitMask = triangleHitMask && (dot(normal, edgePerp) > 0.0);


  if (triangleHitMask)
    return triangleDist;
  else
    return FLT_MAX;
}

float sphereTest(vec3 origin, vec3 direction)
{
  vec3 spherePos = vec3(0.0,0.0,0.0);
  float sphereRadius = 0.1;
  float rayTolerance = 0.000001;
  
  vec3 relativeSpherePos = origin - spherePos;
  float a = dot(direction, direction);
  float b = 2*dot(direction, relativeSpherePos);
  float c = dot(relativeSpherePos, relativeSpherePos) - sphereRadius * sphereRadius;

  float root = b*b - 4*a*c;
  if (root > rayTolerance)
    {
      //lane_f32 farDist = (-b + sqrt(root)) / 2*a;	      
      float nearDist = (-b - sqrt(root)) / 2*a;

      return nearDist;
      //return nearDist / 20.0f;
      /*      bool distMask = (nearDist > minHitDistance) & (nearDist < minDist);
      *dist = nearDist;
      return rootMask & distMask;*/
    }
  return FLT_MAX;
}

float rand(vec2 co){
  return ((fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453))-0.5) * 2.0;
}

