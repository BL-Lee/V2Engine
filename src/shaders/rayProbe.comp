#version 450

struct Vertex {
  vec3 position;
  vec3 normal;
  vec2 texCoord;
  uint materialIndex;
};
struct LineVertex {
  vec3 pos;
  vec3 colour;
};

#define FLT_MAX 1000000.0
layout(std140, set = 0, binding = 0) readonly buffer Vertices {
   Vertex vertices[];
};
layout(std140, set = 0, binding = 1) readonly buffer Indices {
   uint indices[];
};
layout(std140, set = 1, binding = 1) writeonly buffer DebugLines {
   LineVertex lines[];
};

layout(set = 0, binding = 2, rgba8) uniform restrict writeonly image2D frameBuffer; //Temp, its from the ray pipeline descriptor set
layout(set = 1, binding = 0, rgba8) uniform restrict image3D probeInfo[4];
layout(set = 1, binding = 2) uniform sampler3D probeSamplers[4];
//layout(set = 1, binding = 1, rgba8) uniform writeonly image3D probeInfo2;
//layout(set = 1, binding = 1) uniform sampler3D probeSampler;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout( push_constant ) uniform cascadeConstant {
  int cascade;
  int quadrant;
  float start;
  float end;
  int lineView;
} cascadeInfo;


float triangleTest(vec3 rayOrigin, vec3 rayDirection, vec3 v0, vec3 v1, vec3 v2, vec3 normal)
{
	      
  float denom = dot(normal, rayDirection);

  float triangleOffset = -dot(normal, v2); //like the planeDist but for the triangle
  float triangleDist = -(dot(normal, rayOrigin) + triangleOffset) / denom; 
		
  bool triangleHitMask = true;

  if (triangleDist < 0.0001)
    return FLT_MAX;
  vec3 planePoint = (rayDirection * triangleDist) + rayOrigin;
  
  vec3 edge0 = v1 - v0;
  vec3 edgePerp = cross(edge0, planePoint - v0);
  triangleHitMask = triangleHitMask && (dot(normal, edgePerp) > 0.0);

  vec3 edge1 = v2 - v1;
  edgePerp = cross(edge1, planePoint - v1);
  triangleHitMask = triangleHitMask && (dot(normal, edgePerp) > 0.0);

  vec3 edge2 = v0 - v2;
  edgePerp = cross(edge2, planePoint - v2);
  triangleHitMask = triangleHitMask && (dot(normal, edgePerp) > 0.0);


  if (triangleHitMask)
    return triangleDist;
  else
    return FLT_MAX;
}
float rand(vec2 co){
  return ((fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453))-0.5) * 2.0;
}

float pi = 3.14159;
float phi = pi * (sqrt(5.0) - 1.0);
float goldenRatio = (1.0 + pow(5.0,0.5))/2.0;
vec3 center = vec3(0.0, 1.0, 0.0); //Todo: uniform
vec3 width = vec3(2.5);

//Get pixel in image, local to quadrant
ivec3 worldPosToImagePixel(vec3 worldPos, int cascadeIndex)
{
  vec3 probeTexLocation = (worldPos - center) / width;
  probeTexLocation += 0.5;
  int dirCount = int(pow(8, cascadeIndex + 1)); //TODO unhardcode
  int dirTilingCount = int(pow(2, cascadeIndex + 1)); //TODO cube root
      
  //scale down to quadrant 
  vec3 quadrantLocalCoord = probeTexLocation / vec3(dirTilingCount, dirTilingCount, dirTilingCount);

  ivec3 coord = ivec3(quadrantLocalCoord * imageSize(probeInfo[cascadeIndex]));
  return coord;
}



#define MAX_BOUNCE 1
//#define SAMPLE_COUNT 6
void main() {
  vec4 pixel = vec4(0.0);

  int cascadeIndex = cascadeInfo.cascade;//int(gl_GlobalInvocationID.z);
  int SAMPLE_COUNT = int(pow(8, cascadeIndex + 1)); //8, 64, 64*8
  vec4 radiance = vec4(0.0);
  //determine what quadrant we're in
  //Assume powers of two
  int dirTilingCount = int(pow(2, cascadeIndex + 1)); //2, 4, 8

  ivec3 dirTile = ivec3(int(float(gl_GlobalInvocationID.x) / imageSize(probeInfo[cascadeIndex]).x * dirTilingCount),
			int(float(gl_GlobalInvocationID.y) / imageSize(probeInfo[cascadeIndex]).y * dirTilingCount),
			int(float(gl_GlobalInvocationID.z) / imageSize(probeInfo[cascadeIndex]).z * dirTilingCount));
  int dirIndex = dirTile.x + dirTile.y * dirTilingCount + dirTile.z * dirTilingCount * dirTilingCount;

  float y = 1.0 - (dirIndex / float(SAMPLE_COUNT)) * 2.0;
  float radius = sqrt(1.0 - y * y);
  
  float theta = phi * dirIndex;
  float x = cos(theta) * radius;
  float z = sin(theta) * radius;
  vec3 rayDir = vec3(x,y,z);

  


  int gridSize = 32 / int(pow(2, cascadeIndex));
  //Where are we inside this quadrant
  //0-quadrantSize in pixels
  ivec3 localInvocation = ivec3(gl_GlobalInvocationID) - dirTile * (imageSize(probeInfo[cascadeIndex]) / dirTilingCount);

  //vec3 rayDir = normalize(vec3(dirTile)/(dirTilingCount / 2) - 0.5);
  
  vec3 offset = localInvocation;
  offset /= gridSize;
  offset -= 0.5;
  offset *= width;

  /*
  pixel = vec4(rayDir, 1.0);
  imageStore(probeInfo[cascadeIndex], ivec3(gl_GlobalInvocationID.xyz), pixel);
  if (cascadeIndex == cascadeInfo.lineView)
  {
    uint linearIdx = (gl_GlobalInvocationID.x +
		      imageSize(probeInfo[cascadeIndex]).y * gl_GlobalInvocationID.y +
		      imageSize(probeInfo[cascadeIndex]).y * imageSize(probeInfo[cascadeIndex]).z * gl_GlobalInvocationID.z 
		      )
      * 2;
    lines[linearIdx + 0].pos = center + offset;
    lines[linearIdx + 0].colour = pixel.rgb;
    lines[linearIdx + 1].pos = center + offset + rayDir * 0.02;
    lines[linearIdx + 1].colour = pixel.rgb;
  }
  return;
  */
  vec3 rayOrigin = center + offset + (rayDir * cascadeInfo.start);
  float dist = cascadeInfo.end - cascadeInfo.start;
  vec4 emitColour = vec4(0.0);
  uint matIndex = -1;

  for (int i = 0; i < 136; i+=3)
    {
      Vertex v0 = vertices[i + 0];
      Vertex v1 = vertices[i + 1];
      Vertex v2 = vertices[i + 2];
      vec3 normal = v0.normal;
      float testDist = triangleTest(rayOrigin, rayDir,
                                    v0.position, v1.position, v2.position,
                                    normal);

      vec3 avg = v0.position + v1.position + v2.position / 3.0;

      if (testDist < dist && dist > 0.0 && dot(normal, rayDir) < 0.0)
        {
          matIndex = v0.materialIndex;
          dist = testDist;
        }
    }

  if (matIndex == 0) //emissive
    {
      emitColour = vec4(1.0,0.9,0.6,1.0) * 4.0;
      pixel = emitColour;
    }
  else if (matIndex == 1) //diffuseGrey
    {
      pixel = vec4(0.5,0.5,0.5,1.0) * 0.5;
    }
  else if (matIndex == 2) //red
    {
      pixel = vec4(1.0,0.0,0.0,1.0) * 0.5;
    }
  else if (matIndex == 3) //green
    {
      pixel = vec4(0.0,1.0,0.0,1.0) * 0.5;
    }

  pixel.a = 1.0;

  if (cascadeIndex < 3)
    {
      
      ivec3 upperCoord = worldPosToImagePixel(center + offset, cascadeIndex + 1);
      int upperDirCount = int(pow(8, cascadeIndex + 1 + 1)); //TODO unhardcode
      int upperDirTilingCount = int(pow(2, cascadeIndex + 1 + 1)); //TODO cube root
      int contributingDirs = 0;
      vec4 contributingPixel = vec4(0.0);
      for (int dir = 0; dir < upperDirCount; dir++)
	{
	  /*
	  float y = 1.0 - (dirIndex / float(SAMPLE_COUNT)) * 2.0;
	  float radius = sqrt(1.0 - y * y);
  
	  float theta = phi * dirIndex;
	  float x = cos(theta) * radius;
	  float z = sin(theta) * radius;
	  vec3 upperDir = vec3(x,y,z);
	  */
	  ivec3 quadrantOffset = ivec3(dir % upperDirTilingCount,
				       (dir / upperDirTilingCount) % upperDirTilingCount,
				       dir / (upperDirTilingCount * upperDirTilingCount)) * imageSize(probeInfo[cascadeIndex + 1]) / upperDirTilingCount;
	  ivec3 imgCoord = upperCoord + quadrantOffset;
	  vec3 texCoord = vec3(imgCoord) / imageSize(probeInfo[cascadeIndex + 1]) - 0.5;
	  vec4 val = texture(probeSamplers[cascadeIndex + 1], texCoord);
	  if (val != vec4(0.0))
	    {
	      contributingPixel += val;
	      contributingDirs++;
	    }
	  //pixel += imageLoad(probeInfo[cascadeIndex + 1], imgCoord) / upperDirCount;
	}
      if (contributingDirs > 0)
	pixel += contributingPixel / contributingDirs;
    }

  imageStore(probeInfo[cascadeIndex], ivec3(gl_GlobalInvocationID.xyz), pixel);

  if (cascadeIndex == cascadeInfo.lineView)
  {
    uint linearIdx = (gl_GlobalInvocationID.x +
		      imageSize(probeInfo[cascadeIndex]).y * gl_GlobalInvocationID.y +
		      imageSize(probeInfo[cascadeIndex]).y * imageSize(probeInfo[cascadeIndex]).z * gl_GlobalInvocationID.z 
		      )
      * 2;
    lines[linearIdx + 0].pos = center + offset;
    lines[linearIdx + 0].colour = pixel.rgb;
    lines[linearIdx + 1].pos = center + offset + rayDir * 0.02;//dist;
    lines[linearIdx + 1].colour = pixel.rgb;
  }


}
