#version 450

layout(set=1, binding = 1) uniform cameraUniform {
  mat4 view;
  mat4 proj;
  mat4 invViewProj;
  float width;
  float height;
  float nearClip;
  float farClip;
} _MainCamera;

struct Vertex {
  vec3 position;
  vec2 texCoord;
  uint materialIndex;
};
#define FLT_MAX 1000000.0
layout(std140, binding = 0) readonly buffer Vertices {
   Vertex vertices[];
};
layout(std140, binding = 1) readonly buffer Indices {
   uint indices[];
};

layout(binding = 2, rgba8) uniform writeonly image2D frameBuffer;
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

float sphereTest(vec3 origin, vec3 direction)
{
  vec3 spherePos = vec3(0.0,0.0,0.0);
  float sphereRadius = 0.1;
  float rayTolerance = 0.000001;
  
  vec3 relativeSpherePos = origin - spherePos;
  float a = dot(direction, direction);
  float b = 2*dot(direction, relativeSpherePos);
  float c = dot(relativeSpherePos, relativeSpherePos) - sphereRadius * sphereRadius;

  float root = b*b - 4*a*c;
  if (root > rayTolerance)
    {
      //lane_f32 farDist = (-b + sqrt(root)) / 2*a;	      
      float nearDist = (-b - sqrt(root)) / 2*a;

      return nearDist;
      //return nearDist / 20.0f;
      /*      bool distMask = (nearDist > minHitDistance) & (nearDist < minDist);
      *dist = nearDist;
      return rootMask & distMask;*/
    }
  return FLT_MAX;
}

float triangleTest(vec3 rayOrigin, vec3 rayDirection, vec3 v0, vec3 v1, vec3 v2, vec3 normal)
{
	      
  float denom = dot(normal, rayDirection);

  float triangleOffset = -dot(normal, v0);; //like the planeDist but for the triangle
  float triangleDist = -(dot(normal, rayOrigin) + triangleOffset) / denom; 
		
  bool triangleHitMask = triangleDist > 0.001;
		  
  vec3 planePoint = (rayDirection * triangleDist) + rayOrigin;
  
  vec3 edge0 = v1 - v0;
  vec3 edgePerp = cross(edge0, planePoint - v0);
  triangleHitMask = triangleHitMask && (dot(normal, edgePerp) > 0.0);

  vec3 edge1 = v2 - v1;
  edgePerp = cross(edge1, planePoint - v1);
  triangleHitMask = triangleHitMask && (dot(normal, edgePerp) > 0.0);

  vec3 edge2 = v0 - v2;
  edgePerp = cross(edge2, planePoint - v2);
  triangleHitMask = triangleHitMask && (dot(normal, edgePerp) > 0.0);


  if (triangleHitMask)
      return triangleDist;
  else
      return FLT_MAX;
}
float rand(vec2 co){
  return (fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) * 2.0;
}
/*
float triangleTest(vec3 rayOrigin, vec3 rayDirection, vec3 v0, vec3 v1, vec3 v2, vec3 normal)
{
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 ray_cross_e2 = cross(rayDirection, edge2);
    float det = dot(edge1, ray_cross_e2);
    float epsilon = 0.00001;
    if (det > -epsilon && det < epsilon)
        return FLT_MAX;    // This ray is parallel to this triangle.

    float inv_det = 1.0 / det;
    vec3 s = rayOrigin - v0;
    float u = inv_det * dot(s, ray_cross_e2);

    if (u < 0 || u > 1)
        return FLT_MAX;

    vec3 s_cross_e1 = cross(s, edge1);
    float v = inv_det * dot(rayDirection, s_cross_e1);

    if (v < 0 || u + v > 1)
        return FLT_MAX;

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = inv_det * dot(edge2, s_cross_e1);

    if (t > epsilon) // ray intersection
    {
      return t;
    }
    else // This means that there is a line intersection but not a ray intersection.
        return FLT_MAX;
}
*/
#define MAX_BOUNCE 2
void main() {

  vec4 o = (_MainCamera.invViewProj * vec4(0.0, 0.0, 0.0, 1.0));
  vec3 rayOrigin = (o / o.w).xyz;
  vec2 screenCoord = ((gl_GlobalInvocationID.xy / vec2(800.0,800.0)) - 0.5) * 2.0;
  vec4 d = _MainCamera.invViewProj * vec4(screenCoord, 1.0, 1.0);
  vec3 rayDir = (d / d.w).xyz;
  rayDir = normalize(rayDir - rayOrigin);


  vec4 pixel = vec4(0.0);
  vec4 attenuation = vec4(1.0);
  
      
  for (int bounce = 0; bounce < MAX_BOUNCE; bounce++)
    {
      float dist = FLT_MAX;
      vec3 bounceNormal = vec3(0.0);
      vec4 emitColour = vec4(0.0);    
      for (int i = 0; i < 132; i+=3)
        {
          vec3 normal = normalize(cross(vertices[i + 1].position - vertices[i + 0].position,
                              vertices[i + 2].position - vertices[i + 0].position
                                        ));
          float testDist = triangleTest(rayOrigin, rayDir,
                                        vertices[i].position, vertices[i+1].position, vertices[i+2].position,
                                        normal);
          if (testDist < dist)
            {

              if (vertices[i].materialIndex == 0) //emissive
                {
                  emitColour = vec4(1.0,0.0,0.0,1.0);
                }
              else
                {
                  attenuation *= 0.5;
                }
              dist = testDist;
              bounceNormal = rayDir - 2 * normal * dot(rayDir, normal);

            }
        }
      if (dist == FLT_MAX)
        {
          pixel = vec4(0.0);
          break;
        }
      pixel += emitColour * attenuation + dist / 100.0;

      vec3 randomBounce = vec3(rand(rayDir.xy),
                                 rand(rayDir.xy),
                                 rand(rayDir.xy));
                          
      
      rayOrigin = rayOrigin + rayDir * dist;
      rayDir = bounceNormal;
      
    }
  pixel = vec4(pow(pixel.xyz, vec3(1/2.2)),1.0);
  imageStore(frameBuffer, ivec2(gl_GlobalInvocationID.xy), pixel);
}
